<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>Tom Preston-Werner</title>
 <link href="http://tom.preston-werner.com/atom.xml" rel="self"/>
 <link href="http://tom.preston-werner.com/"/>
 <updated>2014-10-07T16:35:50+08:00</updated>
 <id>http://tom.preston-werner.com/</id>
 <author>
   <name>Tom Preston-Werner</name>
   <email>tom@mojombo.com</email>
 </author>

 
 <entry>
   <title>C/C++ problems</title>
   <link href="http://tom.preston-werner.com/2014/09/30/C_and_C%2B%2B.html"/>
   <updated>2014-09-30T00:00:00+08:00</updated>
   <id>http://tom.preston-werner.com/2014/09/30/C_and_C++</id>
   <content type="html">&lt;h1&gt;c/c++ problem conclusion(to be continue!)&lt;/h1&gt;

&lt;p&gt;Recently，I have been involved in progrmming with C/C++ for over 6 years, during this period, some problems(or doubt) always flash in my mind repeatedly, so here, I want to list them from my notebook recursively. And this job will last in my future work life.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;9/30/2014 4:24:03 PM @home&lt;/p&gt;

&lt;h3&gt;Timestamp:2013.04.01-2014.09.30&lt;/h3&gt;

&lt;h4&gt;1. size of void struct?&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;sizeof(void struct)=1Byte
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;2. union&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;All items share the same space&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Only one item can be stored at the same time.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  union StateMachine
  {
      char character;
      int num;
      char *str;
      double exp;
  };
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;strong&gt;note&lt;/strong&gt;:used for compress space&lt;/p&gt;

&lt;h4&gt;3. internal and external data type&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;internal data type: int, char, long...
external data type: enmum, struct, union, class...
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;4. bit operation(right shift and left shift)&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;left shift is easy to be understanded(add 0 at the right end)&lt;/li&gt;
&lt;li&gt;&lt;p&gt;right shift: logical and algorithm shift&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  logical: 0&amp;gt;&amp;gt;NUM(MSB-LSB)&amp;gt;&amp;gt;
  algorithm: MSB&amp;gt;&amp;gt;NUM(MSB-LSB)&amp;gt;&amp;gt;

  int i=-3; // fffffffd
  int j=i&amp;gt;&amp;gt;1; // fffffffe
  int k=i/2; 
  /*
      j=-2;
      k=-1;
  note:negative number do the shift operation in the format of &quot;补码&quot;
  */
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;5. float type storage mechenism&lt;/h4&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2010/06/ieee_floating-point_representation.html&quot;&gt;Click this link&lt;/a&gt;&lt;/p&gt;

&lt;h4&gt;6. const member function&lt;/h4&gt;

&lt;p&gt;Rules for const member function:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Const object can call the const member function, and non const object can call all member function(including const member function)&lt;/li&gt;
&lt;li&gt;The member item of const object can not be modified, howerver, the pointer member is an exception.&lt;/li&gt;
&lt;li&gt;The const member function can not modify object's data(no matter the object is const or not), and meanwhile, this rule will be check while the compilation process.&lt;/li&gt;
&lt;li&gt;&lt;p&gt;When the member item is prefied with &lt;code&gt;mutable&lt;/code&gt;, it can be modified by any kind of method.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  class Stack
  {
  public:
      void Push(int elem);
      int Pop(void);
      int GetCount(void) const;
  private:
      int m_num;
      int m_data[100];
  };
  int Stack::GetCount(void) const
  {
      ++m_num;//error, try to modify member item;
      Pop(); //error, try to call non-const function;
      return m_num;
  }const
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;note&lt;/strong&gt;: The key word &lt;code&gt;const&lt;/code&gt; must place at the end of const member function declaration sentence.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h4&gt;7. Memory allocation scheme of struct&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Caculation of the size of the structure is not just add all structure items' size, what's more, the system allignmemt for the variable item should be took into consideration.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  struct stu1
  {
      int i;  // shift address=0
      char c; // shift address=4
      int j;  // shift address=8
  };
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;Rules to follow(address allocation)

&lt;ul&gt;
&lt;li&gt;The shift address of item must be integeral muliple of the item size;&lt;/li&gt;
&lt;li&gt;The size of structue must be integeral multiple of any item size;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h4&gt;8. printf&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;main()
{
    int b=3;
    int arr[]={6,7,9,9,10};
    int *ptr=arr;
    *(ptr++)+=123;  //ptr 先取值，再自增
    printf(&quot;%d,%d\n&quot;,*ptr,*(++ptr)); //output: 8, 8
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Arguments of the printf function are pushed into the stack from right to left(running from right to left end)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;strong&gt;Ref:&lt;/strong&gt;2.p32.《程序员面试宝典》&lt;/p&gt;

&lt;h4&gt;9. File reading method&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;using C:
int main()
{
    int fd, n;
    char buf[102400];
    fd=open(&quot;C:\\uuu.text&quot;);
    if(-1==fd)
    {
        close(fd);
        return -1;
    }
    n=read(fd,buf,sizeof(buf));
    if((-1==n)||(0==n))
    {
        close(fd);
        return -1;
    }
    *(buf+n)='\n';
    close(fd);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;10.volatile&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;usually, valatile shoule be used before changeable items(in order to avoid compilation opimization), valatile may be prefixed with the following items&lt;/li&gt;
&lt;li&gt;variable used in the interrupt service function&lt;/li&gt;
&lt;li&gt;flag shared by multiple tasks&lt;/li&gt;
&lt;li&gt;hardware register mapped by memory(value is changable during every time read/write)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;strong&gt;note&lt;/strong&gt;: What's more, the data completion should also took into consideration, in the above circustumance, 1 can close the interrupt, 2 can forbidd the task switch, and 3 have to optimazate the hardware design.&lt;/p&gt;

&lt;h4&gt;11.static global variable, static local variable, static function&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;全局变量(外部变量)的说明之前再冠以static 就构成了静态的全局变量。全局变量本身就是静态存储方式，静态全局变量当然也是静态存储方式。这两者在存储方式上并无不同。这两者的区别在于非静态全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。而静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其它源文件中引起错误。 　　&lt;/li&gt;
&lt;li&gt;从以上分析可以看出，把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。　　&lt;/li&gt;
&lt;li&gt;static函数与普通函数作用域不同,仅在本文件。只在当前源文件中使用的函数应该说明为内部函数(static)，内部函数应该在当前源文件中说明和定义。对于可在当前源文件以外使用的函数，应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件。 　　&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&lt;strong&gt;note&lt;/strong&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;static全局变量与普通的全局变量有什么区别：&lt;/p&gt;

&lt;p&gt;  static全局变量只初使化一次，防止在其他文件单元中被引用; 　
　&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;static局部变量和普通局部变量有什么区别：&lt;/p&gt;

&lt;p&gt;  static局部变量只被初始化一次，下一次依据上一次结果值；
　　&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;static函数与普通函数有什么区别：&lt;/p&gt;

&lt;p&gt;  static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h4&gt;12. 函数可重入性&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;每个任务都单独维护自己的栈空间及其自身在内存寄存器中的值，
如果一个函数除了访问自己栈空间或是内核寄存器中的数据外，不
会访问其他任何数据，则这个函数被称为可重入的。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;13. typedef &amp;amp; define&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;In the following examples, we will show the main differences between typedef and define&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  1.  
  typedef char *pstr1;
  #define pstr2 char*;
  pstr1 s1,s2; //error, s2 is char type, not char* pointer
  pstr2 s3,s4; 
  /* `typedef` create an new type, and `define` just do the string replace job*/

  2.
  #define f(x) x*x
  main()
  {
      int a=6, b=2, c;
      c=f(a)/f(b);
      printf(&quot;%d\n&quot;,c); //print 36, x*x/x*x
  }

  3.
  typedef char *pstr;
  char string[4]=&quot;abc&quot;;
  const char *p1=string;
  const pstr p2=string;
  p1++;  
  p2++;   
  /*error `pstr` is regarded as an new type, the key word `const` directly decrated `p2`, so `p2` cann't be modified. */
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; &lt;strong&gt;note:&lt;/strong&gt;
* #define: &lt;code&gt;#ifdef&lt;/code&gt;, &lt;code&gt;#ifndef&lt;/code&gt; and something like this can be used for logical judgement, and &lt;code&gt;#undef&lt;/code&gt; can cancel the definition;
* typedef: It can restrict the range of decoration object(the variable or function just work at it's definiton space).&lt;/p&gt;

&lt;h4&gt;14. Gloabal variable&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;int i;
i=1;  
/*error, global variable can not be defined out of fucntion, the running sequence can not be guranteed. */
int i=1;
int main()
...

.h:
    extern short x;
.c:
    short x=0
/* the global variable declared in .h file , and must be defined in .c file(must prefixed with the type)*/      
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;15. Header file&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Go over how basic compilation of multiple files works.&lt;/p&gt;

&lt;p&gt;  If you have multiple files, the important thing is the difference between the declaration and definition of a function. The definition is probably what you are used to when defining functions: You write up the contents of the function, like&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  int square(int i) 
  {
      return i*i;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  The declaration, on the other hand, lets you declare to the compiler that you know a function exists, but you don't tell the compiler what it is. For example, you could write&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  int square(int i);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  And the compiler would expect that the function &quot;square&quot; is defined elsewhere.
  Now, if you have two different files that you want to interoperate (for example, let's say that the function &quot;square&quot; is defined in add.c, and you want to call square(10) in main.c), you need to do both a definition and a declaration.&lt;/p&gt;

&lt;p&gt;  First, you define square in add.c. Then, you declare it at the beginning of main.c. This let's the compiler know when it is compiling main.c that there is a function &quot;square&quot; which is defined elsewhere. Now, you need to compile both main.c and add.c into object files. You can do this by calling&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  gcc -c main.c
  gcc -c add.c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  This will produce the files main.o and add.o. They contain the compiled functions, but are not quite executable. The important thing to understand here is that main.o is &quot;incomplete&quot; in a sense. When compiling main.o, you told it that the function &quot;square&quot; exists, but the function &quot;square&quot; is not defined inside main.o. Thus main.o has a sort of &quot;dangling reference&quot; to the function &quot;square&quot;. It won't compile into a full program unless you combine it with another .o (or a .so or .a) file which contains a definition of &quot;square&quot;. If you just try to link main.o into a program, i.e.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  gcc -o executable main.o
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  You will get an error, because the compiler will try to resolve the dangling reference to the function &quot;square&quot;, but wont find any definition for it. However, if you include add.o when linking (linking is the process of resolving all these references to undefined functions while converting .o files to executables or .so files), then there won't be any problem. i.e.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  gcc -o executable main.o add.o
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  So that's how to functionally use functions across C files, but stylistically, what I just showed you is &quot;not the right way&quot;. The only reason I did is because I think it will better help you understand what's going on, rather than relying on &quot;#include magic&quot;. Now, you might have noticed before that things get a little messy if you have to redeclare every function you want to use at the top of main.c This is why often C programs use helper files called &quot;headers&quot; which have a .h extension. The idea of a header is that it contains just the declarations of the functions, without their definitions. This way, in order to compile a program using functions defined in add.c, you need not manually declare every function you are using, nor need you #include the entire add.c file in your code. Instead, you can &lt;code&gt;#include add.h&lt;/code&gt;, which simply contains the declarations of all the functions of add.c.&lt;/p&gt;

&lt;p&gt;  Now, a refresher on #include: #include simply &lt;strong&gt;copies&lt;/strong&gt; the contents of one file directly into another. So, for example, the code&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  abc
  #include &quot;wtf.txt&quot;
  def
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  is exactly equivalent to&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  abc
  hello world
  def
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  assuming that wtf.txt contains the text &quot;hello world&quot;.
  So, if we put all the definitions of add.c in add.h (i.e.&lt;code&gt;int square(int i);&lt;/code&gt;)
  and then at the top of main.c, we write &lt;code&gt;#include &quot;add.h&quot;&lt;/code&gt;,This is functionally the same as if we had just manually declared the function &quot;square&quot; at the top of main.c.
  So the general idea of using headers is that you can have a special file that automatically declares all the functions you need by just #including it.&lt;/p&gt;

&lt;p&gt;  However, headers also have one more common use. Let's suppose that main.c uses functions from 50 different files. The top of main.c would look like:
  &lt;code&gt;#include &quot;add.h&quot;&lt;/code&gt;  &lt;code&gt;#include &quot;divide.h&quot;&lt;/code&gt; &lt;code&gt;#include &quot;multiply.h&quot;&lt;/code&gt; &lt;code&gt;#include &quot;eat-pie.h&quot;&lt;/code&gt;...&lt;/p&gt;

&lt;p&gt;  Instead, people often move all those &lt;code&gt;#includes&lt;/code&gt; to the &lt;code&gt;main.h&lt;/code&gt; header file, and just &lt;code&gt;#include main.h&lt;/code&gt; from main.c. In this case, the header file serves two purposes. It declares the functions in main.c for use when included by other files, and it includes all of the dependencies of main.c when included from main.c. Using it this way also allows chains of dependencies. If you &lt;code&gt;#include add.h&lt;/code&gt;, not only do you get the functions defined in add.c, but you also implicitly get any functions which add.c uses, and any functions they use, and so on.&lt;/p&gt;

&lt;p&gt;  Also, more subtly, &lt;code&gt;#including&lt;/code&gt; a header file from it's own .c file implicitly checks for errors you make. If for example, you accidentally defined square as&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  double square(int i);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  in add.h, you normally might not realize until you were linking that main.o is looking for one definition of square, and add.o is providing another, incompatible one. This will cause you to get errors when linking, so you won't realize the mistake until later in the build process. However, if you &lt;code&gt;#include add.h&lt;/code&gt; from add.c, to the compiler, your file looks like&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  #include &quot;add.h&quot;
  int square(int i)
  {
      return i*i;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  which after processing the #include statement will look like&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  double square(int i);
  int square(int i)
  {
      return i*i;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  Which the compiler will notice when compiling add.c, and tell you about. Effectively, including your own header in this way prevents you from falsely advertising to other files the type of the functions you are providing.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Why you can use a function without ever declaring it&lt;/p&gt;

&lt;p&gt;  As you have noticed, in some cases you can actually use a function without every declaring it or &lt;code&gt;#including&lt;/code&gt; any file which declares it. This is stupid, and everyone agrees that this is stupid. However, it is a legacy feature of the C programming language (and C compilers) that if you use a function without declaring it first, it just assumes that it is a function returning type &quot;int&quot;. So in effect, using a function is implicitly declaring that function as a function which returns &quot;int&quot; if it is not already declared. It's very strange behavior if you think about it, and the compiler should warn you if you it doing that behavior.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Header Guards&lt;/p&gt;

&lt;p&gt;  One other common practice is the use of &quot;Header Guards&quot;. To explain header guards, let's look at a possible problem. Let's say that we have two files: herp.c, and derp.c, and they both want to use functions contained in each other. Following the above guidelines, you might have a herp.h with the line&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  #include &quot;derp.h&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  and a derp.h with the line&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  #include &quot;herp.h&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  Now, if you think about it, &lt;code&gt;#include &quot;derp.h&quot;&lt;/code&gt; will be converted to the contents of derp.h, which in turn contains the line #include &quot;herp.h&quot;, which will be converted to the contents of herp.h, and that contains... and so on, so the compiler will go on forever just expanding the includes. Similarly, if main.h &lt;code&gt;#includes&lt;/code&gt; both herp.h and derp.h, and both herp.h and derp.h include add.h, we see that in main.h, we end up withtwo copies of add.h, one as a result of &lt;code&gt;#including&lt;/code&gt; herp.h, and one as a result of including derp.h. So, the solution? A &quot;Header guard&quot;, i.e. a piece of code which prevents any header from being &lt;code&gt;#included&lt;/code&gt; twice. For add.h, for example, the normal way to do this is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  #ifndef ADD_H
  #define ADD_H
  int sqrt(int i);...
  #endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  This piece of code is essentially telling the preprocessor (the part of teh compiler which handles all of the &lt;code&gt;&quot;#XXX&quot;&lt;/code&gt; statements) to check if &lt;code&gt;&quot;ADD_H&quot;&lt;/code&gt; is already defined. If it isn't (ifndef) then it first defines &lt;code&gt;&quot;ADD_H&quot;&lt;/code&gt; (in this context, ADD_H doesn't have to be defined as anything, it is just a boolean which is either defined or not), and then defines the rest of the contents of the header. However, if ADD_H is already defined, then &lt;code&gt;#including&lt;/code&gt; this file will do nothing, because there is nothing outside of the &lt;code&gt;#ifndef&lt;/code&gt; block. So the idea is that only the first time it is included in any given file will it actually add any text to that file. After that, &lt;code&gt;#including&lt;/code&gt; it will not add any additional text to your file. ADD_H is just an arbitrary symbol you choose to keep track of whether add.h has been included yet. For every header, you use a different symbol to keep track of whether it has been included yet or not. For example, herp.h would probably use HERP_H instead of ADD_H. Using a &lt;code&gt;&quot;header guard&quot;&lt;/code&gt; will fix any of the problems I listed above, where you have duplicate copies of a file included, or an infinite loop of &lt;code&gt;#includes&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>天之涯，海之角(三亚)</title>
   <link href="http://tom.preston-werner.com/2014/08/03/sanya.html"/>
   <updated>2014-08-03T00:00:00+08:00</updated>
   <id>http://tom.preston-werner.com/2014/08/03/sanya</id>
   <content type="html">&lt;h1&gt;天之涯，海之角（2014.3.14-2014.4.14）&lt;/h1&gt;

&lt;p&gt;在毕业之前有机会去趟三亚，去见识下阳光照耀下蔚蓝色的真正的大海。出发时是北京的三月份，寒意仍未退去，我也还穿着厚实的冲锋衣，外加秋衣秋裤，怕在飞机上会冷，保持全套原装备上了飞机，直到飞机打开舱门的一刻，我才意识到，穿成那样下飞机，会不会让人觉得脑子进水了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;~/images/sanya/1.jpg&quot; title=&quot;发动机还是劳斯莱斯的..zz&quot; alt=&quot;1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;机场遇到的亚热带清凉美女&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;~/images/sanya/2.jpg&quot; title=&quot;MM&quot; alt=&quot;2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;第一天：徒步三亚桥，大东海，第一市场&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;~/images/sanya/3.jpg&quot; title=&quot;三亚桥&quot; alt=&quot;3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;~/images/sanya/4.jpg&quot; title=&quot;三亚桥&quot; alt=&quot;4&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;~/images/sanya/5.jpg&quot; alt=&quot;5&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;~/images/sanya/6.jpg&quot; alt=&quot;6&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;~/images/sanya/7.jpg&quot; alt=&quot;7&quot; /&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>markdown study</title>
   <link href="http://tom.preston-werner.com/2014/07/19/markdownStudy.html"/>
   <updated>2014-07-19T00:00:00+08:00</updated>
   <id>http://tom.preston-werner.com/2014/07/19/markdownStudy</id>
   <content type="html">&lt;h1&gt;markdown学习&lt;/h1&gt;

&lt;p&gt;2014.07.19 SuZhou&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;第一次markdown亲密接触&lt;/h2&gt;

&lt;p&gt;前些天想了下如何通过jekyll 在github page上进行文字排版，今天重新打开阮一峰的blog，转到其提供的blog参考链接，发现了原来可以抛弃传统的排版思路，通过markdown实现代码式的排版，这有点类似于之前使用过的LaTeX。经过一番尝试，发现其语法结构要比LaTeX简单许多，让我们可以更加专注于文字的表达，顿感相见恨晚，So nice！&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;列表的使用&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt; 如果列表项目间用空行分开，在输出 HTML 时Markdown 就会将项目内容用&lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;标签包起来，举例来说:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  *   Bird

  *   Magic
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;会被转换为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   &amp;lt;ul&amp;gt;
   &amp;lt;li&amp;gt;&amp;lt;p&amp;gt;Bird&amp;lt;/p&amp;gt;&amp;lt;/li&amp;gt;
   &amp;lt;li&amp;gt;&amp;lt;p&amp;gt;Magic&amp;lt;/p&amp;gt;&amp;lt;/li&amp;gt;
   &amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt; 列表可实现嵌套&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;链接&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt; 行内式&lt;/p&gt;

&lt;p&gt;  要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  This is [an example](http://example.com/ &quot;Title&quot;) inline link.

  [This link](http://example.net/) has no title attribute.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  转换为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;p&amp;gt;This is &amp;lt;a href=&quot;http://example.com/&quot; title=&quot;Title&quot;&amp;gt;
  an example&amp;lt;/a&amp;gt; inline link.&amp;lt;/p&amp;gt;

  &amp;lt;p&amp;gt;&amp;lt;a href=&quot;http://example.net/&quot;&amp;gt;This link&amp;lt;/a&amp;gt; has no
  title attribute.&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt; 参考式&lt;/p&gt;

&lt;p&gt;  参考式的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  This is [an example][id] reference-style link.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  你也可以选择性地在两个方括号中间加上一个空格：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  This is [an example] [id] reference-style link.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  接着，在文件的任意处，你可以把这个标记的链接内容定义出来：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  [id]: http://example.com/  &quot;Optional Title Here&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;代码&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt; 行内代码&lt;/p&gt;

&lt;p&gt;  如果要标记一小段行内代码，你可以用反引号把它包起来（`），例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  Use the `printf()` function.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  会产生：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;p&amp;gt;Use the &amp;lt;code&amp;gt;printf()&amp;lt;/code&amp;gt; function.&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;  &lt;strong&gt;note&lt;/strong&gt; :
  如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ``There is a literal backtick (`) here.``
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;图片&lt;/p&gt;

&lt;p&gt;  行内式的图片语法看起来像是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ![Alt text](/path/to/img.jpg)

  ![Alt text](/path/to/img.jpg &quot;Optional title&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  详细叙述如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;一个惊叹号 !&lt;/li&gt;
&lt;li&gt;接着一个方括号，里面放上图片的替代文字&lt;/li&gt;
&lt;li&gt;接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上 选择性的 'title' 文字。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;  参考式的图片语法则长得像这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ![Alt text][id]
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;「id」是图片参考的名称，图片参考的定义方式则和连结参考一样：&lt;/p&gt;

&lt;p&gt;  [id]: url/to/image  &quot;Optional title attribute&quot;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;  &lt;strong&gt;note:&lt;/strong&gt; 到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 &lt;img&gt; 标签。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 
</feed>